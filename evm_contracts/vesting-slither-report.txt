'npx hardhat clean' running (wd: /home/runner/work/Ondrix/Ondrix/bnb_vesting_ondrix)
'npx hardhat clean --global' running (wd: /home/runner/work/Ondrix/Ondrix/bnb_vesting_ondrix)
Problem executing hardhat: [33m[1mWARNING:[22m[39m You are currently using Node.js v18.20.8, which is not supported by Hardhat. This can lead to unexpected behavior. See https://hardhat.org/nodejs-versions

'npx hardhat compile --force' running (wd: /home/runner/work/Ondrix/Ondrix/bnb_vesting_ondrix)
INFO:Detectors:
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) has bitwise-xor operator ^ instead of the exponentiation operator **: 
	 - inverse = (3 * denominator) ^ 2 (node_modules/@openzeppelin/contracts/utils/math/Math.sol#116)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-exponentiation
INFO:Detectors:
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse = (3 * denominator) ^ 2 (node_modules/@openzeppelin/contracts/utils/math/Math.sol#116)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#120)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#121)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#122)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#123)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#124)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#101)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#125)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#104)
	- result = prod0 * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#131)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply
INFO:Detectors:
Reentrancy in ProductionTokenVesting._distributeAllTokens(address) (contracts/TokenVesting.sol#318-366):
	External calls:
	- token.safeTransfer(recipient.wallet,transfers[i_scope_0].amount) (contracts/TokenVesting.sol#354)
	State variables written after the call(s):
	- schedule.lastDistributionTime = block.timestamp (contracts/TokenVesting.sol#365)
	ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48) can be used in cross function reentrancies:
	- ProductionTokenVesting._calculateRecipientClaimableAmount(address,address) (contracts/TokenVesting.sol#421-442)
	- ProductionTokenVesting._calculateTotalClaimableAmount(address) (contracts/TokenVesting.sol#401-419)
	- ProductionTokenVesting._calculateTotalUnlockedAmount(address) (contracts/TokenVesting.sol#444-470)
	- ProductionTokenVesting._findRecipientIndex(address,address) (contracts/TokenVesting.sol#493-503)
	- ProductionTokenVesting.canClaim(address,address) (contracts/TokenVesting.sol#543-565)
	- ProductionTokenVesting.canDistribute(address) (contracts/TokenVesting.sol#527-541)
	- ProductionTokenVesting.getRecipients(address) (contracts/TokenVesting.sol#600-609)
	- ProductionTokenVesting.getVestingProgress(address) (contracts/TokenVesting.sol#623-659)
	- ProductionTokenVesting.getVestingSchedule(address) (contracts/TokenVesting.sol#567-598)
	- ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16) (contracts/TokenVesting.sol#174-263)
	- ProductionTokenVesting.notFinalized() (contracts/TokenVesting.sol#91-94)
	- ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48)
Reentrancy in ProductionTokenVesting.fundVesting(address,uint256) (contracts/TokenVesting.sol#265-303):
	External calls:
	- token.safeTransferFrom(msg.sender,address(this),_amount) (contracts/TokenVesting.sol#287)
	State variables written after the call(s):
	- schedule.totalAmount = _amount (contracts/TokenVesting.sol#297)
	ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48) can be used in cross function reentrancies:
	- ProductionTokenVesting._calculateRecipientClaimableAmount(address,address) (contracts/TokenVesting.sol#421-442)
	- ProductionTokenVesting._calculateTotalClaimableAmount(address) (contracts/TokenVesting.sol#401-419)
	- ProductionTokenVesting._calculateTotalUnlockedAmount(address) (contracts/TokenVesting.sol#444-470)
	- ProductionTokenVesting._findRecipientIndex(address,address) (contracts/TokenVesting.sol#493-503)
	- ProductionTokenVesting.canClaim(address,address) (contracts/TokenVesting.sol#543-565)
	- ProductionTokenVesting.canDistribute(address) (contracts/TokenVesting.sol#527-541)
	- ProductionTokenVesting.getRecipients(address) (contracts/TokenVesting.sol#600-609)
	- ProductionTokenVesting.getVestingProgress(address) (contracts/TokenVesting.sol#623-659)
	- ProductionTokenVesting.getVestingSchedule(address) (contracts/TokenVesting.sol#567-598)
	- ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16) (contracts/TokenVesting.sol#174-263)
	- ProductionTokenVesting.notFinalized() (contracts/TokenVesting.sol#91-94)
	- ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48)
	- schedule.startTime = block.timestamp (contracts/TokenVesting.sol#298)
	ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48) can be used in cross function reentrancies:
	- ProductionTokenVesting._calculateRecipientClaimableAmount(address,address) (contracts/TokenVesting.sol#421-442)
	- ProductionTokenVesting._calculateTotalClaimableAmount(address) (contracts/TokenVesting.sol#401-419)
	- ProductionTokenVesting._calculateTotalUnlockedAmount(address) (contracts/TokenVesting.sol#444-470)
	- ProductionTokenVesting._findRecipientIndex(address,address) (contracts/TokenVesting.sol#493-503)
	- ProductionTokenVesting.canClaim(address,address) (contracts/TokenVesting.sol#543-565)
	- ProductionTokenVesting.canDistribute(address) (contracts/TokenVesting.sol#527-541)
	- ProductionTokenVesting.getRecipients(address) (contracts/TokenVesting.sol#600-609)
	- ProductionTokenVesting.getVestingProgress(address) (contracts/TokenVesting.sol#623-659)
	- ProductionTokenVesting.getVestingSchedule(address) (contracts/TokenVesting.sol#567-598)
	- ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16) (contracts/TokenVesting.sol#174-263)
	- ProductionTokenVesting.notFinalized() (contracts/TokenVesting.sol#91-94)
	- ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48)
	- schedule.isFinalized = true (contracts/TokenVesting.sol#299)
	ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48) can be used in cross function reentrancies:
	- ProductionTokenVesting._calculateRecipientClaimableAmount(address,address) (contracts/TokenVesting.sol#421-442)
	- ProductionTokenVesting._calculateTotalClaimableAmount(address) (contracts/TokenVesting.sol#401-419)
	- ProductionTokenVesting._calculateTotalUnlockedAmount(address) (contracts/TokenVesting.sol#444-470)
	- ProductionTokenVesting._findRecipientIndex(address,address) (contracts/TokenVesting.sol#493-503)
	- ProductionTokenVesting.canClaim(address,address) (contracts/TokenVesting.sol#543-565)
	- ProductionTokenVesting.canDistribute(address) (contracts/TokenVesting.sol#527-541)
	- ProductionTokenVesting.getRecipients(address) (contracts/TokenVesting.sol#600-609)
	- ProductionTokenVesting.getVestingProgress(address) (contracts/TokenVesting.sol#623-659)
	- ProductionTokenVesting.getVestingSchedule(address) (contracts/TokenVesting.sol#567-598)
	- ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16) (contracts/TokenVesting.sol#174-263)
	- ProductionTokenVesting.notFinalized() (contracts/TokenVesting.sol#91-94)
	- ProductionTokenVesting.vestingSchedules (contracts/TokenVesting.sol#48)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1
INFO:Detectors:
ProductionTokenVesting._isValidERC20Token(address) (contracts/TokenVesting.sol#151-172) ignores return value by IERC20(_token).totalSupply() (contracts/TokenVesting.sol#152-155)
ProductionTokenVesting._isValidERC20Token(address) (contracts/TokenVesting.sol#151-172) ignores return value by IERC20(_token).balanceOf(address(this)) (contracts/TokenVesting.sol#157-160)
ProductionTokenVesting._isValidERC20Token(address) (contracts/TokenVesting.sol#151-172) ignores return value by IERC20(_token).allowance(address(this),address(this)) (contracts/TokenVesting.sol#162-165)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return
INFO:Detectors:
ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16) (contracts/TokenVesting.sol#174-263) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(! vestingSchedules[msg.sender].isInitialized,Vesting already initialized) (contracts/TokenVesting.sol#187)
ProductionTokenVesting.fundVesting(address,uint256) (contracts/TokenVesting.sol#265-303) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(schedule.isInitialized,Vesting not initialized) (contracts/TokenVesting.sol#275)
	- require(bool,string)(schedule.startTime == 0,Vesting already funded) (contracts/TokenVesting.sol#276)
	- require(bool,string)(! schedule.isFinalized,Vesting already finalized) (contracts/TokenVesting.sol#277)
	- require(bool,string)(validatedTokens[schedule.token],Token validation revoked) (contracts/TokenVesting.sol#281)
ProductionTokenVesting._distributeAllTokens(address) (contracts/TokenVesting.sol#318-366) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(schedule.startTime > 0,Vesting not funded) (contracts/TokenVesting.sol#320)
	- require(bool,string)(schedule.isFinalized,Vesting not finalized) (contracts/TokenVesting.sol#321)
	- require(bool,string)(block.timestamp >= schedule.lastDistributionTime + DISTRIBUTION_COOLDOWN,Distribution cooldown active) (contracts/TokenVesting.sol#327-330)
	- require(bool,string)(totalClaimable > 0,No tokens available to distribute) (contracts/TokenVesting.sol#334)
	- recipientClaimable > 0 (contracts/TokenVesting.sol#344)
ProductionTokenVesting._claimForRecipient(address,address) (contracts/TokenVesting.sol#368-399) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(schedule.startTime > 0,Vesting not funded) (contracts/TokenVesting.sol#370)
	- require(bool,string)(schedule.isFinalized,Vesting not finalized) (contracts/TokenVesting.sol#371)
	- require(bool,string)(block.timestamp >= recipient.lastClaimTime + DISTRIBUTION_COOLDOWN,Individual claim cooldown active) (contracts/TokenVesting.sol#382-385)
	- require(bool,string)(claimableAmount > 0,No tokens available for recipient) (contracts/TokenVesting.sol#389)
ProductionTokenVesting._calculateTotalClaimableAmount(address) (contracts/TokenVesting.sol#401-419) uses timestamp for comparisons
	Dangerous comparisons:
	- totalUnlocked > totalClaimedByRecipients (contracts/TokenVesting.sol#417-418)
ProductionTokenVesting._calculateRecipientClaimableAmount(address,address) (contracts/TokenVesting.sol#421-442) uses timestamp for comparisons
	Dangerous comparisons:
	- recipientTotalUnlocked > recipient.claimedAmount (contracts/TokenVesting.sol#440-441)
ProductionTokenVesting._calculateTotalUnlockedAmount(address) (contracts/TokenVesting.sol#444-470) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < schedule.startTime + schedule.cliffDuration (contracts/TokenVesting.sol#455)
	- elapsedTime >= schedule.vestingDuration (contracts/TokenVesting.sol#459)
ProductionTokenVesting._validateVestingState(address) (contracts/TokenVesting.sol#472-491) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(totalClaimedByRecipients <= schedule.totalAmount,State inconsistency: claimed exceeds total) (contracts/TokenVesting.sol#484)
ProductionTokenVesting.rescueTokens(address,address,uint256) (contracts/TokenVesting.sol#505-525) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(_token != schedule.token,Cannot rescue vesting tokens) (contracts/TokenVesting.sol#514)
ProductionTokenVesting.canDistribute(address) (contracts/TokenVesting.sol#527-541) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < schedule.lastDistributionTime + DISTRIBUTION_COOLDOWN (contracts/TokenVesting.sol#535)
	- _calculateTotalClaimableAmount(_beneficiary) > 0 (contracts/TokenVesting.sol#540)
ProductionTokenVesting.canClaim(address,address) (contracts/TokenVesting.sol#543-565) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < recipient.lastClaimTime + DISTRIBUTION_COOLDOWN (contracts/TokenVesting.sol#555)
	- _calculateRecipientClaimableAmount(_beneficiary,_recipient) > 0 (contracts/TokenVesting.sol#560)
ProductionTokenVesting.getVestingProgress(address) (contracts/TokenVesting.sol#623-659) uses timestamp for comparisons
	Dangerous comparisons:
	- elapsedTime < schedule.cliffDuration (contracts/TokenVesting.sol#639)
	- elapsedTime >= schedule.vestingDuration (contracts/TokenVesting.sol#641)
	- block.timestamp > schedule.startTime (contracts/TokenVesting.sol#636-637)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp
INFO:Detectors:
Address._revert(bytes,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#231-243) uses assembly
	- INLINE ASM (node_modules/@openzeppelin/contracts/utils/Address.sol#236-239)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#55-134) uses assembly
	- INLINE ASM (node_modules/@openzeppelin/contracts/utils/math/Math.sol#62-66)
	- INLINE ASM (node_modules/@openzeppelin/contracts/utils/math/Math.sol#85-92)
	- INLINE ASM (node_modules/@openzeppelin/contracts/utils/math/Math.sol#99-108)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage
INFO:Detectors:
3 different versions of Solidity are used:
	- Version constraint ^0.8.0 is used by:
		-^0.8.0 (node_modules/@openzeppelin/contracts/access/Ownable.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/utils/Context.sol#4)
		-^0.8.0 (node_modules/@openzeppelin/contracts/utils/math/Math.sol#4)
	- Version constraint ^0.8.1 is used by:
		-^0.8.1 (node_modules/@openzeppelin/contracts/utils/Address.sol#4)
	- Version constraint ^0.8.19 is used by:
		-^0.8.19 (contracts/TestToken.sol#2)
		-^0.8.19 (contracts/TokenVesting.sol#2)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#different-pragma-directives-are-used
INFO:Detectors:
Version constraint ^0.8.0 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)
	- FullInlinerNonExpressionSplitArgumentEvaluationOrder
	- MissingSideEffectsOnSelectorAccess
	- AbiReencodingHeadOverflowWithStaticArrayCleanup
	- DirtyBytesArrayToStorage
	- DataLocationChangeInInternalOverride
	- NestedCalldataArrayAbiReencodingSizeValidation
	- SignedImmutables
	- ABIDecodeTwoDimensionalArrayMemory
	- KeccakCaching.
It is used by:
	- ^0.8.0 (node_modules/@openzeppelin/contracts/access/Ownable.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/utils/Context.sol#4)
	- ^0.8.0 (node_modules/@openzeppelin/contracts/utils/math/Math.sol#4)
Version constraint ^0.8.1 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)
	- FullInlinerNonExpressionSplitArgumentEvaluationOrder
	- MissingSideEffectsOnSelectorAccess
	- AbiReencodingHeadOverflowWithStaticArrayCleanup
	- DirtyBytesArrayToStorage
	- DataLocationChangeInInternalOverride
	- NestedCalldataArrayAbiReencodingSizeValidation
	- SignedImmutables
	- ABIDecodeTwoDimensionalArrayMemory
	- KeccakCaching.
It is used by:
	- ^0.8.1 (node_modules/@openzeppelin/contracts/utils/Address.sol#4)
Version constraint ^0.8.19 contains known severe issues (https://solidity.readthedocs.io/en/latest/bugs.html)
	- VerbatimInvalidDeduplication
	- FullInlinerNonExpressionSplitArgumentEvaluationOrder
	- MissingSideEffectsOnSelectorAccess.
It is used by:
	- ^0.8.19 (contracts/TestToken.sol#2)
	- ^0.8.19 (contracts/TokenVesting.sol#2)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity
INFO:Detectors:
Low level call in SafeERC20._callOptionalReturnBool(IERC20,bytes) (node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol#134-142):
	- (success,returndata) = address(token).call(data) (node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol#139)
Low level call in Address.sendValue(address,uint256) (node_modules/@openzeppelin/contracts/utils/Address.sol#64-69):
	- (success,None) = recipient.call{value: amount}() (node_modules/@openzeppelin/contracts/utils/Address.sol#67)
Low level call in Address.functionCallWithValue(address,bytes,uint256,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#128-137):
	- (success,returndata) = target.call{value: value}(data) (node_modules/@openzeppelin/contracts/utils/Address.sol#135)
Low level call in Address.functionStaticCall(address,bytes,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#155-162):
	- (success,returndata) = target.staticcall(data) (node_modules/@openzeppelin/contracts/utils/Address.sol#160)
Low level call in Address.functionDelegateCall(address,bytes,string) (node_modules/@openzeppelin/contracts/utils/Address.sol#180-187):
	- (success,returndata) = target.delegatecall(data) (node_modules/@openzeppelin/contracts/utils/Address.sol#185)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls
INFO:Detectors:
Function IERC20Permit.DOMAIN_SEPARATOR() (node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol#89) is not in mixedCase
Parameter ProductionTokenVesting.authorizeInitializer(address,bool)._initializer (contracts/TokenVesting.sol#130) is not in mixedCase
Parameter ProductionTokenVesting.authorizeInitializer(address,bool)._authorized (contracts/TokenVesting.sol#130) is not in mixedCase
Parameter ProductionTokenVesting.validateToken(address,bool)._token (contracts/TokenVesting.sol#136) is not in mixedCase
Parameter ProductionTokenVesting.validateToken(address,bool)._valid (contracts/TokenVesting.sol#136) is not in mixedCase
Parameter ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16)._token (contracts/TokenVesting.sol#175) is not in mixedCase
Parameter ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16)._authorizedFunder (contracts/TokenVesting.sol#176) is not in mixedCase
Parameter ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16)._recipients (contracts/TokenVesting.sol#177) is not in mixedCase
Parameter ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16)._cliffDuration (contracts/TokenVesting.sol#178) is not in mixedCase
Parameter ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16)._vestingDuration (contracts/TokenVesting.sol#179) is not in mixedCase
Parameter ProductionTokenVesting.initializeVesting(address,address,ProductionTokenVesting.Recipient[],uint256,uint256,uint16)._tgeBasisPoints (contracts/TokenVesting.sol#180) is not in mixedCase
Parameter ProductionTokenVesting.fundVesting(address,uint256)._beneficiary (contracts/TokenVesting.sol#265) is not in mixedCase
Parameter ProductionTokenVesting.fundVesting(address,uint256)._amount (contracts/TokenVesting.sol#265) is not in mixedCase
Parameter ProductionTokenVesting.claimTokens(address)._beneficiary (contracts/TokenVesting.sol#309) is not in mixedCase
Parameter ProductionTokenVesting.rescueTokens(address,address,uint256)._token (contracts/TokenVesting.sol#506) is not in mixedCase
Parameter ProductionTokenVesting.rescueTokens(address,address,uint256)._to (contracts/TokenVesting.sol#507) is not in mixedCase
Parameter ProductionTokenVesting.rescueTokens(address,address,uint256)._amount (contracts/TokenVesting.sol#508) is not in mixedCase
Parameter ProductionTokenVesting.canDistribute(address)._beneficiary (contracts/TokenVesting.sol#527) is not in mixedCase
Parameter ProductionTokenVesting.canClaim(address,address)._beneficiary (contracts/TokenVesting.sol#543) is not in mixedCase
Parameter ProductionTokenVesting.canClaim(address,address)._recipient (contracts/TokenVesting.sol#543) is not in mixedCase
Parameter ProductionTokenVesting.getVestingSchedule(address)._beneficiary (contracts/TokenVesting.sol#567) is not in mixedCase
Parameter ProductionTokenVesting.getRecipients(address)._beneficiary (contracts/TokenVesting.sol#600) is not in mixedCase
Parameter ProductionTokenVesting.getClaimableAmount(address)._beneficiary (contracts/TokenVesting.sol#611) is not in mixedCase
Parameter ProductionTokenVesting.getRecipientClaimableAmount(address,address)._beneficiary (contracts/TokenVesting.sol#615) is not in mixedCase
Parameter ProductionTokenVesting.getRecipientClaimableAmount(address,address)._recipient (contracts/TokenVesting.sol#615) is not in mixedCase
Parameter ProductionTokenVesting.getVestingProgress(address)._beneficiary (contracts/TokenVesting.sol#623) is not in mixedCase
Parameter ProductionTokenVesting.getBeneficiaryForRecipient(address)._recipient (contracts/TokenVesting.sol#661) is not in mixedCase
Parameter ProductionTokenVesting.isAuthorizedInitializer(address)._initializer (contracts/TokenVesting.sol#665) is not in mixedCase
Parameter ProductionTokenVesting.isTokenValidated(address)._token (contracts/TokenVesting.sol#669) is not in mixedCase
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions
INFO:Detectors:
TestToken.constructor() (contracts/TestToken.sol#8-11) uses literals with too many digits:
	- _mint(msg.sender,1000000 * 10 ** decimals()) (contracts/TestToken.sol#10)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits
INFO:Slither:. analyzed (12 contracts with 100 detectors), 67 result(s) found
